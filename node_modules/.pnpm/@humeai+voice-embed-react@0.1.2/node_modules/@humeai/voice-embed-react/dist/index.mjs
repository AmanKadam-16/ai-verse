'use client';

// src/lib/EmbeddedVoice.ts
import {
  EmbeddedVoice as EA
} from "@humeai/voice-embed";
import { useEffect, useRef } from "react";
var EmbeddedVoice = (props) => {
  const {
    onMessage,
    isEmbedOpen,
    onClose,
    openOnMount = false,
    ...config
  } = props;
  const embeddedVoice = useRef(null);
  const onMessageHandler = useRef();
  onMessageHandler.current = onMessage;
  const onCloseHandler = useRef();
  onCloseHandler.current = onClose;
  const stableConfig = useRef();
  stableConfig.current = config;
  useEffect(() => {
    let unmount;
    if (!embeddedVoice.current && stableConfig.current) {
      embeddedVoice.current = EA.create({
        onMessage: onMessageHandler.current,
        onClose: onCloseHandler.current,
        openOnMount,
        ...stableConfig.current
      });
      unmount = embeddedVoice.current.mount();
    }
    return () => {
      unmount?.();
      embeddedVoice.current = null;
    };
  }, [openOnMount]);
  useEffect(() => {
    if (isEmbedOpen) {
      embeddedVoice.current?.openEmbed();
    }
  }, [isEmbedOpen]);
  return null;
};

// src/index.ts
import {
  COLLAPSE_WIDGET_ACTION,
  EXPAND_WIDGET_ACTION,
  MINIMIZE_WIDGET_ACTION,
  RESIZE_FRAME_ACTION,
  TRANSCRIPT_MESSAGE_ACTION,
  WIDGET_IFRAME_IS_READY_ACTION,
  parseClientToFrameAction,
  LanguageModelOption
} from "@humeai/voice-embed";
export {
  COLLAPSE_WIDGET_ACTION,
  EXPAND_WIDGET_ACTION,
  EmbeddedVoice,
  LanguageModelOption,
  MINIMIZE_WIDGET_ACTION,
  RESIZE_FRAME_ACTION,
  TRANSCRIPT_MESSAGE_ACTION,
  WIDGET_IFRAME_IS_READY_ACTION,
  parseClientToFrameAction
};
//# sourceMappingURL=index.mjs.map